%{
#include "amd64/amd64.h"
#include "op.h"
#include "args.h"

#define YY_INPUT(ctx, buf, result, max_size)   \
{                                              \
    char yyc = ctx->op->text[ctx->idx];        \
    ctx->idx += yyc != 0;                      \
    result = yyc == 0 ? 0 : (*(buf) = yyc, 1); \
}                                              \
%}

# We are assuming the code is compiled with -mno-tls-direct-seg-refs
# so that all TLS accesses are written as mov %fs:0, %reg

Top = ReadTP_rax | ReadTP_any !.

ReadTP_any = 'mov' SEP '%fs:' '0x'? '0' - COMMA r:REG - {
    mkinsn("pushq %%rax");
    mkdirective(".bundle_lock");
    mkinsn("leaq 1f(%%rip), %%r11");
    mkinsn("jmpq *8(%%r14)");
    mklabel("1");
    mkdirective(".bundle_unlock");
    mkinsn("movq %%rax, %s", r.val);
    mkinsn("popq %%rax");
    rfree(r);
}

ReadTP_rax = 'mov' SEP '%fs:' '0x'? '0' - COMMA '%rax' - {
    mkdirective(".bundle_lock");
    mkinsn("leaq 1f(%%rip), %%r11");
    mkinsn("jmpq *8(%%r14)");
    mklabel("1");
    mkdirective(".bundle_unlock");
}

%%

void
amd64_tlspass(struct op* op)
{
    if (!op->insn)
        return;
    yycontext ctx;
    memset(&ctx, 0, sizeof(yycontext));
    ctx.op = op;
    oplocate(op);
    if (yyparse(&ctx)) {
        opremove(op);
        opfree(op);
    }
    yyrelease(&ctx);
}
